name: iOS Deploy to TestFlight

on:
  workflow_dispatch:
    inputs:
      configuration:
        description: Build configuration
        type: choice
        options:
          - Release
          - Debug
        default: Release
      bump_build_number:
        description: Bump CFBundleVersion (date-based)
        type: boolean
        default: true

env:
  APP_NAME: offLLM
  SCHEME: monGARS
  BUNDLE_ID: com.offllm.mongars
  WORKSPACE: ios/monGARS.xcworkspace
  CONFIGURATION: ${{ inputs.configuration }}
  TEAM_ID: 52T7P32J34
  EXPORT_METHOD: app-store

jobs:
  deploy-testflight:
    runs-on: macos-15
    environment: offLLM
    timeout-minutes: 60
    permissions:
      contents: read

    steps:
      - name: ‚úÖ Validate Secrets (and base64 sanity)
        env:
          IOS_P12_BASE64: ${{ secrets.IOS_P12_BASE64 }}
          IOS_P12_PASSWORD: ${{ secrets.IOS_P12_PASSWORD }}
          IOS_PROVISIONING_PROFILE_BASE64: ${{ secrets.IOS_PROVISIONING_PROFILE_BASE64 }}
          ASC_KEY_ID: ${{ secrets.ASC_KEY_ID }}
          ASC_ISSUER_ID: ${{ secrets.ASC_ISSUER_ID }}
          ASC_PRIVATE_KEY_BASE64: ${{ secrets.ASC_PRIVATE_KEY_BASE64 }}
        run: |
          set -euo pipefail
          missing=0
          for var in IOS_P12_BASE64 IOS_P12_PASSWORD IOS_PROVISIONING_PROFILE_BASE64 ASC_KEY_ID ASC_ISSUER_ID ASC_PRIVATE_KEY_BASE64; do
            if [ -z "${!var:-}" ]; then
              echo "::error::Missing $var"
              missing=1
            fi
          done
          [ "$missing" -eq 0 ] || exit 1

          clean_b64() { printf '%s' "$1" | tr -d '\n\r\t ' ; }
          b64_decode_to() {
            local in="$1"; local out="$2"
            if base64 -D </dev/null >/dev/null 2>&1; then
              printf '%s' "$in" | base64 -D > "$out"
            else
              printf '%s' "$in" | base64 --decode > "$out"
            fi
          }

          tmp="$RUNNER_TEMP/b64check"
          mkdir -p "$tmp"
          b64_decode_to "$(clean_b64 "$IOS_P12_BASE64")" "$tmp/cert.p12" || { echo "::error::IOS_P12_BASE64 invalid"; exit 1; }
          b64_decode_to "$(clean_b64 "$ASC_PRIVATE_KEY_BASE64")" "$tmp/key.p8" || { echo "::error::ASC_PRIVATE_KEY_BASE64 invalid"; exit 1; }
          b64_decode_to "$(clean_b64 "$IOS_PROVISIONING_PROFILE_BASE64")" "$tmp/profile.mobileprovision" || { echo "::error::IOS_PROVISIONING_PROFILE_BASE64 invalid"; exit 1; }

          security cms -D -i "$tmp/profile.mobileprovision" >/dev/null || {
            echo "::error::Provisioning profile decodes but is not a valid .mobileprovision"
            exit 1
          }

      - name: üßæ Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: üß∞ Select Xcode
        run: bash scripts/ci/select_xcode.sh

      - name: üç∫ Install XcodeGen
        run: |
          brew update
          brew install xcodegen
          xcodegen --version

      - name: üíé Ensure Ruby tools
        run: |
          command -v xcpretty >/dev/null 2>&1 || sudo gem install xcpretty --no-document
          command -v pod >/dev/null 2>&1 || sudo gem install cocoapods --no-document
          pod --version
          xcpretty --version

      - name: üîê Setup Keychain + Import Cert
        env:
          P12_BASE64: ${{ secrets.IOS_P12_BASE64 }}
          P12_PASSWORD: ${{ secrets.IOS_P12_PASSWORD }}
        run: |
          set -euo pipefail
          clean_b64() { printf '%s' "$1" | tr -d '\n\r\t ' ; }
          b64_decode_to() {
            local in="$1"; local out="$2"
            if base64 -D </dev/null >/dev/null 2>&1; then
              printf '%s' "$in" | base64 -D > "$out"
            else
              printf '%s' "$in" | base64 --decode > "$out"
            fi
          }

          KEYCHAIN="$RUNNER_TEMP/build.keychain-db"
          KEYPASS="$(openssl rand -hex 12)"
          security create-keychain -p "$KEYPASS" "$KEYCHAIN"
          security set-keychain-settings -lut 21600 "$KEYCHAIN"
          security unlock-keychain -p "$KEYPASS" "$KEYCHAIN"

          CERT_P12="$RUNNER_TEMP/cert.p12"
          b64_decode_to "$(clean_b64 "$P12_BASE64")" "$CERT_P12"
          security import "$CERT_P12" -k "$KEYCHAIN" -P "$P12_PASSWORD" -T /usr/bin/codesign -T /usr/bin/security

          security list-keychains -d user -s "$KEYCHAIN" $(security list-keychains -d user | tr -d '"')
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYPASS" "$KEYCHAIN"

          echo "KEYCHAIN_PATH=$KEYCHAIN" >> "$GITHUB_ENV"
          echo "KEYCHAIN_PASSWORD=$KEYPASS" >> "$GITHUB_ENV"

          echo "Available code signing identities (sanity):"
          security find-identity -v -p codesigning "$KEYCHAIN" || true

      - name: ü™™ Install Provisioning Profile (extract UUID + Name)
        env:
          PROFILE_B64: ${{ secrets.IOS_PROVISIONING_PROFILE_BASE64 }}
        run: |
          set -euo pipefail
          clean_b64() { printf '%s' "$1" | tr -d '\n\r\t ' ; }
          b64_decode_to() {
            local in="$1"; local out="$2"
            if base64 -D </dev/null >/dev/null 2>&1; then
              printf '%s' "$in" | base64 -D > "$out"
            else
              printf '%s' "$in" | base64 --decode > "$out"
            fi
          }

          mkdir -p "$HOME/Library/MobileDevice/Provisioning Profiles"

          OUT="$RUNNER_TEMP/app.mobileprovision"
          b64_decode_to "$(clean_b64 "$PROFILE_B64")" "$OUT"

          security cms -D -i "$OUT" > "$RUNNER_TEMP/app.mobileprovision.plist"
          UUID=$(/usr/libexec/PlistBuddy -c "Print:UUID" "$RUNNER_TEMP/app.mobileprovision.plist")
          NAME=$(/usr/libexec/PlistBuddy -c "Print:Name" "$RUNNER_TEMP/app.mobileprovision.plist" 2>/dev/null || true)

          if [[ -z "$UUID" || ! "$UUID" =~ ^[A-Fa-f0-9-]{36}$ ]]; then
            echo "::error::Failed to extract UUID from provisioning profile."
            exit 1
          fi

          mv "$OUT" "$HOME/Library/MobileDevice/Provisioning Profiles/$UUID.mobileprovision"

          echo "PROFILE_UUID=$UUID" >> "$GITHUB_ENV"
          if [ -n "${NAME:-}" ]; then
            echo "PROFILE_NAME=$NAME" >> "$GITHUB_ENV"
            echo "Installed provisioning profile: $NAME ($UUID)"
          else
            echo "::warning::Could not extract profile Name; will rely on UUID only."
            echo "Installed provisioning profile UUID: $UUID"
          fi

      - name: üß± Generate Xcode project + install pods
        working-directory: ios
        run: |
          set -euo pipefail
          xcodegen generate
          pod install --verbose

          if [ ! -d "monGARS.xcworkspace" ]; then
            echo "::error::Expected monGARS.xcworkspace to exist after pod install."
            ls -la
            exit 1
          fi

      - name: üß© Ensure shared scheme exists AND supports ArchiveAction
        run: |
          set -euo pipefail

          echo "WORKSPACE=$WORKSPACE"
          echo "SCHEME=$SCHEME"

          # Find the *real* app project (NOT Pods) that contains PBXNativeTarget named $SCHEME.
          project_path="$(python3 - <<'PY'
import os, re, pathlib, sys

ios = pathlib.Path("ios")
target = os.environ.get("SCHEME","").strip()
if not target:
    print("")
    sys.exit(0)

candidates = []
for proj in ios.glob("*.xcodeproj"):
    if proj.name == "Pods.xcodeproj":
        continue
    pbx = proj / "project.pbxproj"
    if not pbx.exists():
        continue
    txt = pbx.read_text(encoding="utf-8", errors="ignore")
    # Match "/* monGARS */ = {isa = PBXNativeTarget;"
    if re.search(r"/\*\s*%s\s*\*/\s*=\s*\{isa\s*=\s*PBXNativeTarget;" % re.escape(target), txt):
        candidates.append(proj)

if not candidates:
    print("")
    sys.exit(0)

# Prefer monGARS.xcodeproj if it exists, else first match.
preferred = ios / "monGARS.xcodeproj"
if preferred in candidates:
    print(str(preferred))
else:
    print(str(candidates[0]))
PY
)"

          if [[ -z "$project_path" || ! -d "$project_path" ]]; then
            echo "::error::Could not find an .xcodeproj containing PBXNativeTarget '$SCHEME' (excluding Pods)."
            echo "::group::Projects seen"
            find ios -maxdepth 1 -type d -name "*.xcodeproj" -print || true
            echo "::endgroup::"
            exit 1
          fi

          echo "::notice::Using project: $project_path"

          pbxproj="${project_path}/project.pbxproj"
          scheme_dir="${project_path}/xcshareddata/xcschemes"
          mkdir -p "$scheme_dir"
          scheme_path="${scheme_dir}/${SCHEME}.xcscheme"

          # Extract target ID from pbxproj
          target_id="$(python3 - <<'PY'
import os, re, pathlib, sys
pbx = pathlib.Path(os.environ["PBX"])
tgt = os.environ["TGT"]
txt = pbx.read_text(encoding="utf-8", errors="ignore")
m = re.search(r"([A-F0-9]{24}) /\* %s \*/ = \{isa = PBXNativeTarget;" % re.escape(tgt), txt)
if not m:
    print("")
    sys.exit(1)
print(m.group(1))
PY
)" || true

          if [[ -z "$target_id" ]]; then
            echo "::error::Failed to extract PBXNativeTarget id for '$SCHEME' from $pbxproj"
            exit 1
          fi

          # If scheme exists but lacks ArchiveAction, rewrite it.
          needs_write="1"
          if [[ -f "$scheme_path" ]]; then
            if grep -q "<ArchiveAction" "$scheme_path"; then
              needs_write="0"
            fi
          fi

          if [[ "$needs_write" == "1" ]]; then
            echo "::notice::Writing/repairing shared scheme with ArchiveAction: $scheme_path"
            cat >"$scheme_path" <<EOF
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion="1600"
   version="1.3">
   <BuildAction parallelizeBuildables="YES" buildImplicitDependencies="YES">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting="YES"
            buildForRunning="YES"
            buildForProfiling="YES"
            buildForArchiving="YES"
            buildForAnalyzing="YES">
            <BuildableReference
               BuildableIdentifier="primary"
               BlueprintIdentifier="${target_id}"
               BuildableName="${SCHEME}.app"
               BlueprintName="${SCHEME}"
               ReferencedContainer="container:$(basename "$project_path")">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration="Debug"
      selectedDebuggerIdentifier="Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier="Xcode.DebuggerFoundation.Launcher.LLDB"
      shouldUseLaunchSchemeArgsEnv="YES">
      <Testables/>
   </TestAction>
   <LaunchAction
      buildConfiguration="Debug"
      selectedDebuggerIdentifier="Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier="Xcode.DebuggerFoundation.Launcher.LLDB"
      launchStyle="0"
      useCustomWorkingDirectory="NO"
      ignoresPersistentStateOnLaunch="NO"
      debugDocumentVersioning="YES"
      debugServiceExtension="internal"
      allowLocationSimulation="YES">
      <BuildableProductRunnable runnableDebuggingMode="0">
         <BuildableReference
            BuildableIdentifier="primary"
            BlueprintIdentifier="${target_id}"
            BuildableName="${SCHEME}.app"
            BlueprintName="${SCHEME}"
            ReferencedContainer="container:$(basename "$project_path")">
         </BuildableReference>
      </BuildableProductRunnable>
   </LaunchAction>
   <ProfileAction
      buildConfiguration="Release"
      shouldUseLaunchSchemeArgsEnv="YES"
      savedToolIdentifier=""
      useCustomWorkingDirectory="NO"
      debugDocumentVersioning="YES">
      <BuildableProductRunnable runnableDebuggingMode="0">
         <BuildableReference
            BuildableIdentifier="primary"
            BlueprintIdentifier="${target_id}"
            BuildableName="${SCHEME}.app"
            BlueprintName="${SCHEME}"
            ReferencedContainer="container:$(basename "$project_path")">
         </BuildableReference>
      </BuildableProductRunnable>
   </ProfileAction>
   <AnalyzeAction buildConfiguration="Debug"/>
   <ArchiveAction buildConfiguration="Release" revealArchiveInOrganizer="YES"/>
</Scheme>
EOF
          fi

          echo "::group::Shared schemes on disk"
          find ios -type f -path "*/xcshareddata/xcschemes/*.xcscheme" -maxdepth 7 -print || true
          echo "::endgroup::"

          echo "::group::xcodebuild -list (workspace)"
          xcodebuild -list -workspace "$WORKSPACE" || true
          echo "::endgroup::"

          # Hard gate: scheme file MUST contain ArchiveAction now.
          if ! grep -q "<ArchiveAction" "$scheme_path"; then
            echo "::error::Scheme file still missing ArchiveAction: $scheme_path"
            sed -n '1,200p' "$scheme_path" || true
            exit 1
          fi

        env:
          PBX: ios/monGARS.xcodeproj/project.pbxproj
          TGT: ${{ env.SCHEME }}

      - name: üß™ Verify workspace + scheme (hard gate)
        run: |
          set -euo pipefail
          test -d "$WORKSPACE" || { echo "::error::Workspace missing: $WORKSPACE"; exit 1; }

          list_json="$(xcodebuild -list -json -workspace "$WORKSPACE" 2>/dev/null)"
          python3 - <<'PY' <<<"$list_json"
import json, os, sys
data=json.loads(sys.stdin.read())
schemes=(data.get("workspace") or {}).get("schemes") or []
print("Schemes:")
for s in schemes:
    print("  -", s)
want=os.environ["SCHEME"]
if want not in schemes:
    raise SystemExit(f"::error::Expected SCHEME '{want}' not found in workspace schemes")
print(f"::notice::Scheme '{want}' is visible in workspace.")
PY

      - name: üè∑Ô∏è Bump build number
        if: ${{ inputs.bump_build_number }}
        run: |
          set -euo pipefail
          /usr/libexec/PlistBuddy -c "Set :CFBundleVersion $(date +%Y%m%d%H%M)" ios/MyOfflineLLMApp/Info.plist

      - name: üßæ Write ExportOptions.plist
        working-directory: ios
        run: |
          set -euo pipefail
          PROFILE_REF="${PROFILE_NAME:-$PROFILE_UUID}"

          cat > ExportOptions.plist <<EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0"><dict>
            <key>method</key><string>${EXPORT_METHOD}</string>
            <key>teamID</key><string>${TEAM_ID}</string>
            <key>signingStyle</key><string>manual</string>
            <key>provisioningProfiles</key>
            <dict>
              <key>${BUNDLE_ID}</key><string>${PROFILE_REF}</string>
            </dict>
            <key>stripSwiftSymbols</key><true/>
            <key>uploadSymbols</key><true/>
          </dict></plist>
EOF

      - name: üîé Detect signing identity
        run: |
          set -euo pipefail
          IDENTITY_LINE="$(security find-identity -v -p codesigning "$KEYCHAIN_PATH" \
            | grep -E 'Apple Distribution|iPhone Distribution|Apple Development|iPhone Developer' \
            | head -n 1 || true)"
          if [ -z "$IDENTITY_LINE" ]; then
            echo "::error::No code signing identity found in keychain."
            security find-identity -v -p codesigning "$KEYCHAIN_PATH" || true
            exit 1
          fi
          SIGNING_IDENTITY="$(printf '%s' "$IDENTITY_LINE" | sed -n 's/.*"\(.*\)".*/\1/p')"
          if [ -z "$SIGNING_IDENTITY" ]; then
            echo "::error::Failed to parse signing identity."
            echo "$IDENTITY_LINE"
            exit 1
          fi
          echo "SIGNING_IDENTITY=$SIGNING_IDENTITY" >> "$GITHUB_ENV"
          echo "Using signing identity: $SIGNING_IDENTITY"

      - name: üèóÔ∏è Archive (always writes xcresult; dumps failures)
        id: archive
        continue-on-error: true
        run: |
          set -euo pipefail
          mkdir -p build/logs

          RESULT_BUNDLE="$RUNNER_TEMP/archive.xcresult"
          RAW_LOG="build/logs/archive-xcodebuild-raw.log"

          EXTRA_PROFILE_ARGS=()
          if [ -n "${PROFILE_NAME:-}" ]; then
            EXTRA_PROFILE_ARGS+=( "PROVISIONING_PROFILE_SPECIFIER=$PROFILE_NAME" )
          fi

          echo "Archiving with:"
          echo "  WORKSPACE=$WORKSPACE"
          echo "  SCHEME=$SCHEME"
          echo "  CONFIGURATION=$CONFIGURATION"
          echo "  BUNDLE_ID=$BUNDLE_ID"
          echo "  TEAM_ID=$TEAM_ID"
          echo "  PROFILE_NAME=${PROFILE_NAME:-}"
          echo "  PROFILE_UUID=$PROFILE_UUID"
          echo "  SIGNING_IDENTITY=$SIGNING_IDENTITY"
          echo "  RESULT_BUNDLE=$RESULT_BUNDLE"

          set +e
          xcodebuild archive \
            -workspace "$WORKSPACE" \
            -scheme "$SCHEME" \
            -configuration "$CONFIGURATION" \
            -destination "generic/platform=iOS" \
            -archivePath "$RUNNER_TEMP/${APP_NAME}.xcarchive" \
            -derivedDataPath "$RUNNER_TEMP/DerivedData" \
            -resultBundlePath "$RESULT_BUNDLE" \
            CODE_SIGNING_ALLOWED=YES \
            CODE_SIGNING_REQUIRED=YES \
            PRODUCT_BUNDLE_IDENTIFIER="$BUNDLE_ID" \
            DEVELOPMENT_TEAM="$TEAM_ID" \
            CODE_SIGN_STYLE=Manual \
            CODE_SIGN_IDENTITY="$SIGNING_IDENTITY" \
            OTHER_CODE_SIGN_FLAGS="--keychain $KEYCHAIN_PATH" \
            "${EXTRA_PROFILE_ARGS[@]}" \
            2>&1 | tee "$RAW_LOG" | xcpretty
          xc_status=${PIPESTATUS[0]}
          set -e

          echo "ARCHIVE_XCRESULT=$RESULT_BUNDLE" >> "$GITHUB_ENV"

          if [ "$xc_status" -ne 0 ]; then
            echo "::error::xcodebuild archive failed with exit code $xc_status"
            echo "---- tail (raw xcodebuild) ----"
            tail -n 200 "$RAW_LOG" || true
            exit "$xc_status"
          fi

          echo "ARCHIVE_PATH=$RUNNER_TEMP/${APP_NAME}.xcarchive" >> "$GITHUB_ENV"

      - name: üßæ If archive failed, dump xcresult issues (action errors)
        if: ${{ steps.archive.outcome != 'success' }}
        run: |
          set -euo pipefail
          echo "Archive failed; attempting to extract errors from xcresult‚Ä¶"
          if [ -z "${ARCHIVE_XCRESULT:-}" ] || [ ! -d "${ARCHIVE_XCRESULT:-}" ]; then
            echo "::warning::No xcresult bundle found at ARCHIVE_XCRESULT=${ARCHIVE_XCRESULT:-}"
            exit 0
          fi

          echo "::group::xcresulttool - actions invocation record"
          xcrun xcresulttool get --path "$ARCHIVE_XCRESULT" --format json | python3 -c $'import json,sys\n\ndata=json.load(sys.stdin)\n\ndef walk(obj, path=\"\"):\n    if isinstance(obj, dict):\n        for k, v in obj.items():\n            np=f\"{path}.{k}\" if path else k\n            if k in (\"issueSummaries\",\"issues\",\"errors\",\"warnings\") and v:\n                print(f\"\\n== {np} ==\")\n                print(json.dumps(v, indent=2)[:20000])\n            walk(v, np)\n    elif isinstance(obj, list):\n        for i, v in enumerate(obj):\n            walk(v, f\"{path}[{i}]\")\n\nwalk(data)\n'
          echo "::endgroup::"

          echo "::error::Archive failed. See log tail above + xcresult dumps."
          exit 1

      - name: üì¶ Export IPA
        run: |
          set -euo pipefail
          mkdir -p build/logs

          xcodebuild -exportArchive \
            -archivePath "$ARCHIVE_PATH" \
            -exportPath build/output \
            -exportOptionsPlist ios/ExportOptions.plist \
            2>&1 | tee build/logs/export-xcodebuild-raw.log | xcpretty

          IPA="$(find build/output -name '*.ipa' -print -quit)"
          if [ -z "$IPA" ]; then
            echo "::error::No IPA produced."
            exit 1
          fi
          echo "IPA_PATH=$IPA" >> "$GITHUB_ENV"
          echo "IPA: $IPA"

      - name: üöÄ Upload to TestFlight
        env:
          ASC_KEY_ID: ${{ secrets.ASC_KEY_ID }}
          ASC_ISSUER_ID: ${{ secrets.ASC_ISSUER_ID }}
          ASC_PRIVATE_KEY_BASE64: ${{ secrets.ASC_PRIVATE_KEY_BASE64 }}
        run: bash scripts/ci/upload_testflight.sh "$IPA_PATH" "$ASC_KEY_ID" "$ASC_ISSUER_ID" "$ASC_PRIVATE_KEY_BASE64"

      - name: üßπ Cleanup keychain
        if: always()
        run: |
          security delete-keychain "$KEYCHAIN_PATH" || true

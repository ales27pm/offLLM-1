name: iOS â€¢ Deploy to TestFlight

on:
  workflow_dispatch:
    inputs:
      configuration:
        description: Build configuration
        type: choice
        options:
          - Release
          - Debug
        default: Release
      bump_build_number:
        description: Bump CFBundleVersion (date-based)
        type: boolean
        default: true
      xcode_major:
        description: Xcode major version to use
        type: choice
        options:
          - "16"
          - "15"
        default: "16"

env:
  APP_NAME: offLLM
  # Can be overwritten automatically after scheme detection.
  SCHEME: monGARS
  BUNDLE_ID: com.offllm.mongars
  WORKSPACE: ios/monGARS.xcworkspace
  CONFIGURATION: ${{ inputs.configuration }}
  TEAM_ID: 52T7P32J34
  EXPORT_METHOD: app-store

jobs:
  deploy-testflight:
    runs-on: macos-15
    environment: offLLM
    timeout-minutes: 60
    permissions:
      contents: read

    steps:
      - name: âœ… Validate Secrets (and base64 sanity)
        run: |
          set -euo pipefail
          missing=0
          for var in \
            IOS_DIST_CERT_BASE64 \
            IOS_DIST_CERT_PASSWORD \
            IOS_PROVISIONING_PROFILE_BASE64 \
            ASC_KEY_ID \
            ASC_ISSUER_ID \
            ASC_PRIVATE_KEY_BASE64
          do
            if [ -z "${!var:-}" ]; then
              echo "::error::Missing secret: $var"
              missing=1
            fi
          done
          if [ "$missing" -ne 0 ]; then
            exit 1
          fi

          # quick base64 sanity checks
          echo "${IOS_DIST_CERT_BASE64}" | tr -d '\n\r\t ' | base64 --decode >/dev/null 2>&1 || {
            echo "::error::IOS_DIST_CERT_BASE64 is not valid base64"
            exit 1
          }
          echo "${IOS_PROVISIONING_PROFILE_BASE64}" | tr -d '\n\r\t ' | base64 --decode >/dev/null 2>&1 || {
            echo "::error::IOS_PROVISIONING_PROFILE_BASE64 is not valid base64"
            exit 1
          }
          echo "${ASC_PRIVATE_KEY_BASE64}" | tr -d '\n\r\t ' | base64 --decode >/dev/null 2>&1 || {
            echo "::error::ASC_PRIVATE_KEY_BASE64 is not valid base64"
            exit 1
          }

        env:
          IOS_DIST_CERT_BASE64: ${{ secrets.IOS_DIST_CERT_BASE64 }}
          IOS_DIST_CERT_PASSWORD: ${{ secrets.IOS_DIST_CERT_PASSWORD }}
          IOS_PROVISIONING_PROFILE_BASE64: ${{ secrets.IOS_PROVISIONING_PROFILE_BASE64 }}
          ASC_KEY_ID: ${{ secrets.ASC_KEY_ID }}
          ASC_ISSUER_ID: ${{ secrets.ASC_ISSUER_ID }}
          ASC_PRIVATE_KEY_BASE64: ${{ secrets.ASC_PRIVATE_KEY_BASE64 }}

      - name: ðŸ§¾ Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 1

      - name: ðŸ§° Select Xcode + Ensure iPhoneOS SDK
        run: bash scripts/ci/select_xcode_and_ensure_ios.sh "16"

      - name: ðŸ“¦ Ensure iPhoneOS SDK present
        run: bash scripts/ci/ensure_ios_platform.sh

      - name: ðŸº Install XcodeGen
        run: |
          brew update
          brew install xcodegen
          xcodegen --version

      - name: ðŸ’Ž Ensure Ruby tools
        run: |
          command -v xcpretty >/dev/null 2>&1 || sudo gem install xcpretty --no-document
          command -v cocoapods >/dev/null 2>&1 || sudo gem install cocoapods --no-document
          xcpretty --version
          pod --version

      - name: ðŸ” Setup Keychain + Import Cert
        env:
          P12_BASE64: ${{ secrets.P12_BASE64 }}
          P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
        run: |
          set -euo pipefail

          clean_b64() { printf '%s' "$1" | tr -d '\n\r\t '; }

          KEYCHAIN_PATH="$HOME/Library/Keychains/build-signing.keychain-db"
          KEYCHAIN_PASSWORD="${KEYCHAIN_PASSWORD:-$(uuidgen)}"
          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> "$GITHUB_ENV"
          echo "KEYCHAIN_PASSWORD=$KEYCHAIN_PASSWORD" >> "$GITHUB_ENV"

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security list-keychains -d user -s "$KEYCHAIN_PATH" "$HOME/Library/Keychains/login.keychain-db"
          security default-keychain -d user -s "$KEYCHAIN_PATH"

          CERT_P12="$RUNNER_TEMP/dist.p12"
          clean_b64 "$P12_BASE64" | base64 --decode > "$CERT_P12"
          if [[ ! -s "$CERT_P12" ]]; then
            echo "::error::Decoded signing certificate is empty. Check P12_BASE64."
            exit 1
          fi

          if ! openssl pkcs12 -in "$CERT_P12" -passin "pass:$P12_PASSWORD" -info -nokeys >/dev/null 2>&1; then
            echo "::error::Signing certificate is not a valid PKCS#12 archive or the password is incorrect."
            echo "::error::Verify P12_BASE64 is a .p12/.pfx and P12_PASSWORD matches."
            exit 1
          fi

          security import "$CERT_P12" -k "$KEYCHAIN_PATH" -P "$P12_PASSWORD" -T /usr/bin/codesign -T /usr/bin/security -T /usr/bin/xcodebuild
          security set-key-partition-list -S apple-tool:,apple: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          security find-identity -v -p codesigning "$KEYCHAIN_PATH" || true

      - name: ðŸªª Install Provisioning Profile (extract UUID + Name)
        env:
          IOS_PROVISIONING_PROFILE_BASE64: ${{ secrets.IOS_PROVISIONING_PROFILE_BASE64 }}
        run: |
          set -euo pipefail
          clean_b64() { printf '%s' "$1" | tr -d '\n\r\t '; }

          mkdir -p "$HOME/Library/MobileDevice/Provisioning Profiles"
          OUT="$RUNNER_TEMP/profile.mobileprovision"
          clean_b64 "$IOS_PROVISIONING_PROFILE_BASE64" | base64 --decode > "$OUT"

          # Extract UUID + Name
          PLIST="$RUNNER_TEMP/profile.plist"
          security cms -D -i "$OUT" > "$PLIST"

          UUID=$(/usr/libexec/PlistBuddy -c "Print :UUID" "$PLIST" 2>/dev/null || true)
          NAME=$(/usr/libexec/PlistBuddy -c "Print :Name" "$PLIST" 2>/dev/null || true)

          if [[ -z "$UUID" || ! "$UUID" =~ ^[A-Fa-f0-9-]{36}$ ]]; then
            echo "::error::Failed to extract UUID from provisioning profile."
            exit 1
          fi

          mv "$OUT" "$HOME/Library/MobileDevice/Provisioning Profiles/$UUID.mobileprovision"

          echo "PROFILE_UUID=$UUID" >> "$GITHUB_ENV"
          if [ -n "${NAME:-}" ]; then
            echo "PROFILE_NAME=$NAME" >> "$GITHUB_ENV"
            echo "Installed provisioning profile: $NAME ($UUID)"
          else
            echo "::warning::Could not extract profile Name; will rely on UUID only."
            echo "Installed provisioning profile UUID: $UUID"
          fi

      - name: ðŸ§± Generate Xcode project + install pods
        working-directory: ios
        run: |
          set -euo pipefail
          xcodegen generate
          pod install --project-directory=.

      - name: Ensure shared app scheme exists
        run: |
          set -euo pipefail
          if [ ! -d "ios" ]; then
            echo "::error::Expected ios/ directory to exist."
            exit 1
          fi
          ls -la ios || true

      - name: ðŸ§ª List all app schemes + bundle identifiers
        working-directory: ios
        run: |
          set -euo pipefail
          xcodebuild -workspace "monGARS.xcworkspace" -list || true
          echo ""
          echo "Bundle IDs in project (best-effort):"
          rg -n "PRODUCT_BUNDLE_IDENTIFIER" -S . || true

      - name: ðŸ§  Auto-detect app scheme by matching PRODUCT_BUNDLE_IDENTIFIER
        working-directory: ios
        env:
          TARGET_BUNDLE_ID: ${{ env.BUNDLE_ID }}
        run: |
          set -euo pipefail

          # Look for scheme names via xcodebuild -list parsing
          schemes=$(xcodebuild -workspace "monGARS.xcworkspace" -list 2>/dev/null | awk '
            $0 ~ /^Schemes:/ {inSchemes=1; next}
            inSchemes && NF==0 {exit}
            inSchemes {print $1}
          ' | sed '/^$/d' || true)

          if [ -z "${schemes:-}" ]; then
            echo "::error::No schemes found in workspace."
            exit 1
          fi

          echo "Candidate schemes:"
          echo "$schemes"

          # Prefer the configured SCHEME if it exists.
          if echo "$schemes" | grep -qx "${SCHEME}"; then
            echo "SCHEME=${SCHEME}" >> "$GITHUB_ENV"
            echo "Using configured scheme: ${SCHEME}"
            exit 0
          fi

          # Fallback: pick first scheme
          picked="$(echo "$schemes" | head -n 1)"
          echo "SCHEME=${picked}" >> "$GITHUB_ENV"
          echo "::warning::Configured scheme not found; using fallback scheme: ${picked}"

      - name: ðŸ·ï¸ Bump build number
        if: ${{ inputs.bump_build_number }}
        working-directory: ios
        run: |
          set -euo pipefail
          # Date-based build number: YYYYMMDDHHMM
          BUILD_NUMBER="$(date +%Y%m%d%H%M)"
          echo "Bumping CFBundleVersion to ${BUILD_NUMBER}"

          # Try agvtool first if configured
          if command -v agvtool >/dev/null 2>&1; then
            agvtool new-version -all "${BUILD_NUMBER}" || true
          fi

          # Fallback: brute-force bump in Info.plist files if present
          plists=$(find . -name "Info.plist" -maxdepth 5 -print 2>/dev/null || true)
          for p in $plists; do
            /usr/libexec/PlistBuddy -c "Set :CFBundleVersion ${BUILD_NUMBER}" "$p" 2>/dev/null || true
          done

      - name: ðŸ§¾ Write ExportOptions.plist
        working-directory: ios
        run: |
          set -euo pipefail
          mkdir -p build
          cat > build/exportOptions.plist <<'PLIST'
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
            <key>method</key><string>app-store</string>
            <key>signingStyle</key><string>manual</string>
            <key>stripSwiftSymbols</key><true/>
            <key>uploadSymbols</key><true/>
            <key>compileBitcode</key><false/>
          </dict>
          </plist>
          PLIST
          echo "EXPORT_OPTIONS_PLIST=$PWD/build/exportOptions.plist" >> "$GITHUB_ENV"
          /usr/bin/plutil -lint build/exportOptions.plist

      - name: ðŸ”Ž Detect signing identity
        run: |
          set -euo pipefail
          security find-identity -v -p codesigning "$KEYCHAIN_PATH" || true

      - name: ðŸ—ï¸ Archive (always writes xcresult; dumps failures)
        id: archive
        continue-on-error: true
        env:
          SCHEME: ${{ env.SCHEME }}
          WORKING_DIR: ios
          DERIVED_DATA: build/DerivedData
          ARCHIVE_PATH: build/monGARS.xcarchive
          EXPORT_DIR: build/export
          RESULT_BUNDLE: build/DerivedData/ResultBundle_build.xcresult
          XCODE_PROJECT_NAME: monGARS.xcodeproj
          PROFILE_UUID: ${{ env.PROFILE_UUID }}
          PROFILE_NAME: ${{ env.PROFILE_NAME }}
          KEYCHAIN_PATH: ${{ env.KEYCHAIN_PATH }}
          TEAM_ID: ${{ env.TEAM_ID }}
          BUNDLE_ID: ${{ env.BUNDLE_ID }}
        run: |
          set -euo pipefail
          mkdir -p build/logs

          RESULT_BUNDLE="$RUNNER_TEMP/archive.xcresult"
          RAW_LOG="build/logs/archive-xcodebuild-raw.log"

          EXTRA_PROFILE_ARGS=()
          if [ -n "${PROFILE_NAME:-}" ]; then
            EXTRA_PROFILE_ARGS+=( "PROVISIONING_PROFILE_SPECIFIER=$PROFILE_NAME" )
          fi

          echo "Archiving with:"
          echo "  SCHEME=$SCHEME"
          echo "  TEAM_ID=$TEAM_ID"
          echo "  BUNDLE_ID=$BUNDLE_ID"
          echo "  PROFILE_UUID=${PROFILE_UUID:-}"
          echo "  PROFILE_NAME=${PROFILE_NAME:-}"

          test -n "$TEAM_ID"
          PROJECT_FLAG="-workspace monGARS.xcworkspace"

          mkdir -p "${DERIVED_DATA}"

          set -o pipefail
          xcodebuild \
            $PROJECT_FLAG \
            -scheme "${SCHEME}" \
            -configuration Release \
            -destination "generic/platform=iOS" \
            -archivePath "${ARCHIVE_PATH}" \
            -derivedDataPath "${DERIVED_DATA}" \
            -resultBundlePath "${RESULT_BUNDLE}" \
            CODE_SIGN_STYLE=Manual \
            DEVELOPMENT_TEAM="${TEAM_ID}" \
            PRODUCT_BUNDLE_IDENTIFIER="${BUNDLE_ID}" \
            OTHER_CODE_SIGN_FLAGS="--keychain ${KEYCHAIN_PATH}" \
            "${EXTRA_PROFILE_ARGS[@]}" \
            clean archive \
            2>&1 | tee "$RAW_LOG" | xcpretty

          exit ${PIPESTATUS[0]}

      - name: ðŸ§¾ If archive failed, dump xcresult issues (action errors)
        if: ${{ steps.archive.outcome != 'success' }}
        run: |
          set -euo pipefail
          echo "::error::Archive step failed. Showing last 250 lines of raw xcodebuild log:"
          tail -n 250 build/logs/archive-xcodebuild-raw.log || true
          exit 1

      - name: ðŸ“¦ Export IPA
        working-directory: ios
        env:
          ARCHIVE_PATH: build/monGARS.xcarchive
          EXPORT_DIR: build/export
          EXPORT_OPTIONS_PLIST: ${{ env.EXPORT_OPTIONS_PLIST }}
          KEYCHAIN_PATH: ${{ env.KEYCHAIN_PATH }}
        run: |
          set -euo pipefail
          mkdir -p "$EXPORT_DIR"

          xcodebuild \
            -exportArchive \
            -archivePath "$ARCHIVE_PATH" \
            -exportPath "$EXPORT_DIR" \
            -exportOptionsPlist "$EXPORT_OPTIONS_PLIST" \
            OTHER_CODE_SIGN_FLAGS="--keychain ${KEYCHAIN_PATH}" \
            | xcpretty

          IPA="$(find "$EXPORT_DIR" -maxdepth 2 -name '*.ipa' -print | head -n 1 || true)"
          if [ -z "$IPA" ]; then
            echo "::error::IPA not found in $EXPORT_DIR"
            find "$EXPORT_DIR" -maxdepth 2 -print || true
            exit 1
          fi
          echo "IPA_PATH=$IPA" >> "$GITHUB_ENV"
          echo "IPA: $IPA"

      - name: ðŸš€ Upload to TestFlight
        env:
          ASC_KEY_ID: ${{ secrets.ASC_KEY_ID }}
          ASC_ISSUER_ID: ${{ secrets.ASC_ISSUER_ID }}
          ASC_PRIVATE_KEY_BASE64: ${{ secrets.ASC_PRIVATE_KEY_BASE64 }}
        run: bash scripts/ci/upload_testflight.sh "$IPA_PATH" "$ASC_KEY_ID" "$ASC_ISSUER_ID" "$ASC_PRIVATE_KEY_BASE64"

      - name: ðŸ§¹ Cleanup keychain
        if: always()
        run: |
          security delete-keychain "$KEYCHAIN_PATH" || true

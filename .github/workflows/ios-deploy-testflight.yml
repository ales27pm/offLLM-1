name: iOS â€¢ Deploy to TestFlight

on:
  workflow_dispatch:
    inputs:
      configuration: { type: choice, options: [Release, Debug], default: Release }
      bump_build_number: { type: boolean, default: true }

env:
  APP_NAME: offLLM
  SCHEME: monGARS
  BUNDLE_ID: com.offllm.mongars
  WORKSPACE: ios/monGARS.xcworkspace
  CONFIGURATION: ${{ inputs.configuration || 'Release' }}
  TEAM_ID: 52T7P32J34
  EXPORT_METHOD: app-store

jobs:
  deploy-testflight:
    runs-on: macos-15
    environment: offLLM
    timeout-minutes: 60
    permissions: { contents: read }

    steps:
      - name: âœ… Validate Secrets
        env:
          IOS_P12_BASE64: ${{ secrets.IOS_P12_BASE64 }}
          IOS_P12_PASSWORD: ${{ secrets.IOS_P12_PASSWORD }}
          IOS_PROVISIONING_PROFILE_BASE64: ${{ secrets.IOS_PROVISIONING_PROFILE_BASE64 }}
          ASC_KEY_ID: ${{ secrets.ASC_KEY_ID }}
          ASC_ISSUER_ID: ${{ secrets.ASC_ISSUER_ID }}
          ASC_PRIVATE_KEY_BASE64: ${{ secrets.ASC_PRIVATE_KEY_BASE64 }}
        run: |
          set -euo pipefail
          missing=0

          for var in IOS_P12_BASE64 IOS_P12_PASSWORD IOS_PROVISIONING_PROFILE_BASE64 ASC_KEY_ID ASC_ISSUER_ID ASC_PRIVATE_KEY_BASE64; do
            if [ -z "${!var:-}" ]; then
              echo "::error::Missing $var"
              missing=1
            fi
          done

          if [ "$missing" -ne 0 ]; then
            exit 1
          fi

          # Base64 sanity checks (DO NOT print secrets)
          # macOS base64 uses -D; GNU uses --decode. We support both.
          decode_test() {
            local name="$1"
            local raw="${!name}"
            local cleaned
            cleaned="$(printf '%s' "$raw" | tr -d '\n\r\t ')"

            if base64 -D </dev/null >/dev/null 2>&1; then
              printf '%s' "$cleaned" | base64 -D >/dev/null 2>&1 || {
                echo "::error::$name is not valid base64 (macOS decoder)"
                exit 1
              }
            else
              printf '%s' "$cleaned" | base64 --decode >/dev/null 2>&1 || {
                echo "::error::$name is not valid base64 (GNU decoder)"
                exit 1
              }
            fi
          }

          decode_test IOS_P12_BASE64
          decode_test IOS_PROVISIONING_PROFILE_BASE64
          decode_test ASC_PRIVATE_KEY_BASE64

      - uses: actions/checkout@v4
        with: { fetch-depth: 1 }

      - run: bash scripts/ci/select_xcode.sh

      - name: ðŸº Install XcodeGen
        run: |
          brew update
          brew install xcodegen
          xcodegen --version

      - name: ðŸ’Ž Ensure Ruby tools
        run: |
          command -v xcpretty >/dev/null 2>&1 || sudo gem install xcpretty --no-document
          command -v pod >/dev/null 2>&1 || sudo gem install cocoapods --no-document
          pod --version

      - name: ðŸ§± Generate Xcode project + install pods
        working-directory: ios
        run: |
          xcodegen generate
          pod install --verbose

      - if: ${{ inputs.bump_build_number }}
        run: /usr/libexec/PlistBuddy -c "Set :CFBundleVersion $(date +%Y%m%d%H%M)" ios/MyOfflineLLMApp/Info.plist

      - name: ðŸ” Setup Keychain
        env:
          P12_BASE64: ${{ secrets.IOS_P12_BASE64 }}
          P12_PASSWORD: ${{ secrets.IOS_P12_PASSWORD }}
        run: |
          set -euo pipefail

          KEYCHAIN="$RUNNER_TEMP/build.keychain-db"
          KEYPASS="$(openssl rand -hex 12)"

          security create-keychain -p "$KEYPASS" "$KEYCHAIN"
          security set-keychain-settings -lut 21600 "$KEYCHAIN"
          security unlock-keychain -p "$KEYPASS" "$KEYCHAIN"

          # Normalize base64 (remove whitespace / CRLF)
          CLEAN_P12="$(printf '%s' "$P12_BASE64" | tr -d '\n\r\t ')"

          # Decode using macOS base64 (-D)
          printf '%s' "$CLEAN_P12" | base64 -D > "$RUNNER_TEMP/cert.p12"

          security import "$RUNNER_TEMP/cert.p12" \
            -k "$KEYCHAIN" \
            -P "$P12_PASSWORD" \
            -T /usr/bin/codesign \
            -T /usr/bin/security

          security list-keychains -d user -s "$KEYCHAIN" $(security list-keychains -d user | tr -d '"')
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYPASS" "$KEYCHAIN"

          echo "KEYCHAIN_PATH=$KEYCHAIN" >> "$GITHUB_ENV"

      - name: ðŸªª Install Profile
        env:
          PROFILE_B64: ${{ secrets.IOS_PROVISIONING_PROFILE_BASE64 }}
        run: |
          set -euo pipefail

          if [ -z "${PROFILE_B64:-}" ]; then
            echo "::error::IOS_PROVISIONING_PROFILE_BASE64 is empty"
            exit 1
          fi

          mkdir -p "$HOME/Library/MobileDevice/Provisioning Profiles"

          python3 - <<'PY'
          import os, re, base64, pathlib, sys, subprocess

          b64 = os.environ["PROFILE_B64"]
          b64 = re.sub(r"\s+", "", b64)  # kill CRLF/whitespace/paste poison

          try:
              data = base64.b64decode(b64, validate=True)
          except Exception as e:
              print("::error::IOS_PROVISIONING_PROFILE_BASE64 is not valid base64")
              raise

          out = pathlib.Path(os.environ["RUNNER_TEMP"]) / "app.mobileprovision"
          out.write_bytes(data)

          # Must be parseable by security cms
          plist = pathlib.Path(os.environ["RUNNER_TEMP"]) / "app.mobileprovision.plist"
          subprocess.run(["security", "cms", "-D", "-i", str(out)], check=True, stdout=plist.open("wb"))

          # Extract UUID
          uuid = subprocess.check_output(
              ["/usr/libexec/PlistBuddy", "-c", "Print:UUID", str(plist)],
              text=True
          ).strip()

          if not re.fullmatch(r"[A-Fa-f0-9-]{36}", uuid or ""):
              print("::error::Failed to extract UUID from provisioning profile (decoded file is not a valid profile)")
              sys.exit(1)

          dest = pathlib.Path.home() / "Library/MobileDevice/Provisioning Profiles" / f"{uuid}.mobileprovision"
          out.replace(dest)

          # Export for later steps
          with open(os.environ["GITHUB_ENV"], "a", encoding="utf-8") as f:
              f.write(f"PROFILE_UUID={uuid}\n")
          PY


      - name: ðŸ§¾ Write ExportOptions
        working-directory: ios
        run: |
          set -euo pipefail
          cat > ExportOptions.plist <<EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0"><dict>
            <key>method</key><string>${EXPORT_METHOD}</string>
            <key>teamID</key><string>${TEAM_ID}</string>
            <key>compileBitcode</key><false/>
            <key>signingStyle</key><string>manual</string>
            <key>provisioningProfiles</key><dict><key>${BUNDLE_ID}</key><string>${PROFILE_UUID}</string></dict>
            <key>stripSwiftSymbols</key><true/>
            <key>uploadSymbols</key><true/>
          </dict></plist>
          EOF

      - name: ðŸ—ï¸ Archive
        run: |
          set -o pipefail
          mkdir -p build/logs
          xcodebuild archive \
            -workspace "$WORKSPACE" \
            -scheme "$SCHEME" \
            -configuration "$CONFIGURATION" \
            -destination "generic/platform=iOS" \
            -archivePath "$RUNNER_TEMP/${APP_NAME}.xcarchive" \
            PRODUCT_BUNDLE_IDENTIFIER="$BUNDLE_ID" \
            DEVELOPMENT_TEAM="$TEAM_ID" \
            CODE_SIGN_STYLE=Manual \
            CODE_SIGNING_ALLOWED=YES \
            CODE_SIGNING_REQUIRED=YES \
            | tee build/logs/archive.log | xcpretty
          echo "ARCHIVE_PATH=$RUNNER_TEMP/${APP_NAME}.xcarchive" >> "$GITHUB_ENV"

      - name: ðŸ“¦ Export IPA
        run: |
          set -o pipefail
          xcodebuild -exportArchive \
            -archivePath "$ARCHIVE_PATH" \
            -exportPath build/output \
            -exportOptionsPlist ios/ExportOptions.plist \
            | tee build/logs/export.log | xcpretty

          IPA=$(find build/output -name '*.ipa' -print -quit)
          echo "IPA_PATH=$IPA" >> "$GITHUB_ENV"

      - name: ðŸš€ Upload
        env:
          ASC_KEY_ID: ${{ secrets.ASC_KEY_ID }}
          ASC_ISSUER_ID: ${{ secrets.ASC_ISSUER_ID }}
          ASC_PRIVATE_KEY_BASE64: ${{ secrets.ASC_PRIVATE_KEY_BASE64 }}
        run: bash scripts/ci/upload_testflight.sh "$IPA_PATH" "$ASC_KEY_ID" "$ASC_ISSUER_ID" "$ASC_PRIVATE_KEY_BASE64"

      - if: always()
        run: security delete-keychain "$KEYCHAIN_PATH" || true
